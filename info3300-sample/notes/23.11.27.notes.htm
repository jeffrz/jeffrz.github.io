<html><head>
<title>INFO 3300 - November 27</title>

  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  
  <link rel="stylesheet" type="text/css" href="../css/normalize.css">
  <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="../css/custom-style.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">
  <link rel="stylesheet" href="../css/hljs-base16.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  
  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <style>
  </style>

</head>
<body>
  <div class="container larger">
    
    <h3>Notes for November 27</h3>
    <p>Today we'll work with graph data once again. However, this time we will be placing emphasis on the edges between nodes rather than the structural relationship between nodes. For example, while it might be useful to spot character clusters in Les Mis√©rables, you need a different visual metaphor if you want to show more clearly the intensity of interactions *between* characters. Today we'll try out a chord diagram to expose the edges more saliently. While we won't get to in in class, there are also a wide variety of hierarchical visualizations available when you want to show nesting and structural details in a network.</p>
    
    <p>Today's dataset comes from a larger dataset of <a href="https://kaggle.com/mmmarchetti/game-of-thrones-network-analysis">character co-occurrences in the Game of Thrones book series</a>. I aggregated data into a final, sparse dataset of character relationships that show high co-occurrence (>50 interactions across 5 books). If you're a fan of the books and it makes you feel better, I promise I'll update the dataset for Winds of Winter if it ever comes out.</p>
    
    <p><a href="https://observablehq.com/@d3/chord-diagram">Here</a> is an Observable example of a chord diagram. <a href="http://bl.ocks.org/nbremer/94db779237655907b907">This one</a> attempts to add some interactivity.</p>
    
    <p>The <a href="https://github.com/d3/d3-chord">d3 chord library</a> has lots of helpful functions. We'll also be making use of the arc generator from <a href="https://github.com/d3/d3-shape">d3-shape</a>.</p>
    
    <p>To make a color palette for 20 different categories, I used the <a href="http://vrl.cs.brown.edu/color">Colorgorical</a> color optimization tool. <a href="https://projects.susielu.com/viz-palette">Viz Palette</a> is a decent way to test out different color scheme ideas.</p>
  
  
  
    <h5>HTML for today:</h5>
    
    <svg id="chord" height="850" width="850" style="background: #fff; margin-top:50px" >
    </svg>
    



  <!-- This block will be automatically filled with syntax-highlighted code from the script below -->
  <h5>Code for today:</h5>
  <pre>
    <code id="display1" class="hljs javascript">
    </code>
  </pre>


  <script id="notes1">
  
  // Layer for drawing
  const width = d3.select("#chord").attr("width");
  const height = d3.select("#chord").attr("height");
  const chordChart = d3.select("#chord").append("g");
  
  const drawChord = async () => {
    
    // We'll use a color palette generated by this neat optimization tool: http://vrl.cs.brown.edu/color
    const colorPalette = ["#48bf8e", "#075c62", "#a1def0", "#5e2a96", 
                          "#e775cc", "#f3c5fa", "#9a76af", "#1c4585", 
                          "#479abc", "#94ea5b", "#1d6d1f", "#cddb9b", 
                          "#604020", "#d48f4d", "#f24219", "#8e1023", 
                          "#8c956d", "#2cf52b", "#ff0087", "#e9d737"]

    // Load GoT dataset
    const got = await d3.json("../datasets/thrones-cooccur.json");
    console.log(got);
    
    let nodes = got.nodes;
    let links = got.edges;
    
    // The d3.chord function needs a 2d matrix of flow in order to function ( a *dense edge matrix* )
    // This doesn't seem like the best design choice, but as we saw in the previous lecture, it's common
    // We'll create one from our *sparse edge list* data
    
    // Make zeroed-out matrix that's a square of nodes.length size
    let matrix = []; // dense edge matrix
    let connections = {};  // To save some time later, we'll also store lists of connections between nodes
    for (let i=0; i<nodes.length; i++) { 
        let row = [];
        for (let j=0; j<nodes.length; j++) { row.push(0); }
        
        matrix.push(row);
        connections[i] = [i]; // everything connected to itself!
    }
    console.log(matrix);
    
    // Now build the edge matrix -- we'll use cooccurrence in the cells to show the "weight" of each edge
    links.forEach( d => {
      
      // Add in if statement to avoid linking unlinked items
      if (d.weight > 0) {
      
        // Thankfully, the links have extra data for the index of their source and target
        //   (I actually generated this by using a dictionary and then console.log(JSON.stringify(got)) )
        // As edges are bidirectional, we'll fill in two cells of the matrix for each one
        matrix[d.sourceIndex][d.targetIndex] = d.weight;
        matrix[d.targetIndex][d.sourceIndex] = d.weight;
        
        connections[d.sourceIndex].push(d.targetIndex);
        connections[d.targetIndex].push(d.sourceIndex);
        
      }
    });
    // Anything left unfilled remains at 0, which will draw no ribbons
    console.log(matrix);
    console.log(connections);
    
    let radius = (width / 2.0) - 125;
    
    // Make a chord diagram generator
    let chordGen = d3.chord()
                    .padAngle(.04)
                    .sortSubgroups(d3.descending)
                    .sortChords(d3.descending)
    // Make an outer arc generator
    let arcGen = d3.arc()
                    .innerRadius(radius)
                    .outerRadius(radius + 20)
    // Make a ribbon generator
    let ribbonGen = d3.ribbon()
                      .radius(radius)
    
    // Feed in the matrix
    let chords = chordGen(matrix);
    console.log(chords);
    
    // NOTICE: The chord gen ONLY looks at the matrix
    //  If you ever want to make use of node metadata, then you have to look up by index
    //  This is why it's critical to line up the indices in the matrix with nodes indices
    
    // One note - the chord diagram is going to draw at 0,0
    // The easiest solution is to translate the layer
    chordChart.attr("transform",`translate(${width/2.0},${height/2.0})`);
    
    // Make the outer ring
    let colorScale = d3.scaleOrdinal().range(colorPalette);

    // We'll use a data join to make a G tag and then make paths within it using the data for the ring
    let ringContainer = chordChart.append("g");
    let rings = ringContainer.selectAll("g.segment")
                            .data(chords.groups)
                            .join("g")
                            .attr("class","segment");
                            
    // Make each ring segment using the arc generator
    // Note that the chord gen has already created data that the arc generator needs
    rings.append("path")
         .attr("fill", d => colorScale( nodes[ d.index ].Affiliation ))
         .attr("stroke", d => colorScale( nodes[ d.index ].Affiliation ))
         .attr("d", arcGen);


    // Now make a path for each ribbon using a data join
    // Same as before, the chord gen has created the data necessary for the ribbon generator
    let ribbonContainer = chordChart.append("g");
    let ribbons = ribbonContainer.selectAll("path.ribbon")
                      .data(chords)
                      .join("path")
                      .attr("class","ribbon")
                      .attr("fill-opacity", 0.5)
                      .attr("stroke", "none")
                      .attr("fill", d => colorScale( nodes[ d.source.index ].Affiliation ))
                      .attr("d", ribbonGen);
    
    
    
    // Adding in the labels
    // We want them to go around the circle, so we have to be a bit clever here
    // To accomplish this, we will make a transform for each label that shifts it around the circle
    // * For clarity, we'll make a new property in the dataset for the transform
    //   This could also all be done in one line during an append if you're sneaky
    
    // ** Remember that transforms work from the end of the string back to the front **
    //    We need to first move it out and then rotate it around the circle
    //    If we have to flip the text, we want to do it first
    chords.groups.forEach( d => {
      // We will store a transform for each ring element
      let transform = '';
      
      // find midpoint, convert to degrees
      let midpoint = (d.startAngle + d.endAngle) / 2;
      let rotation = ( midpoint ) * ( 180 / Math.PI ) - 90;
      
      // Now build up the transform
      // We're going to rotate text labels around the ring like a clock
      // First, we translate to extend it out from the 0,0 point
      // Then we rotate the extended text about the 0,0 axis
      //  (the commands look reversed because transform runs from end to start)
      transform = transform + ` rotate(${rotation})`;
      transform = transform + ` translate(${radius+25}, 0)`;
      
      // If we're on the left half of circle, then flip the text first!
      if (rotation > 90) {
        transform = transform + ' rotate(180)';
        // Notice text anchor issue -- the flipped ones intrude on the circle
        //  That's because their text anchor is set to "start" by default
        // Rather than adjust the translate so they fit, just change the text anchor!
        d.anchor = "end";
      }
      d.transform = transform;
    });
    
    rings.append("text")
         .attr("transform", d => d.transform)
         .text(d => nodes[ d.index ].Name )
         .attr("text-anchor", d => d.anchor); // if d.anchor is undefined, it falls back
                                              //  to the default of "start"
    
    
    
    // Add interactions
    // Highlighting functions
    // First, we make some blanket functions to show and hide all elements 
    //  In this case, "hide" means more like "make them less obvious"
    function restoreHighlights() {
      rings.attr("opacity", 1);   // both text and ring
      ribbons.attr("opacity", 1);
    }
    function lowlightAll() {
      rings.attr("opacity", 0.2); // both text and ring
      ribbons.attr("opacity", 0.2);
    }
    
    // Now, we'll make functions that show things in mouseovers
    //  The challenge in this part is picking out the right segments to highlight
    function highlightRings(index) {
      // We'll do a filter of elements based on their data
      //  (This works just like an array filter but for data joined elements in a selectAll )
      // Here *rings* is the result of svg.selectAll("g.segment").data().join(), not an array
      let targetSegments = rings.filter( d => {
        return connections[d.index].includes(index);    // JS: arr.includes(x) === Python: x in arr 
      });
      targetSegments.attr("opacity",1);
    }
    
    // Same filter, but this time for ribbons -- remember we need to check BOTH source and target
    function highlightRibbons(index) {
      let targetRibbons = ribbons.filter( d => {
        return d.source.index === index || d.target.index === index;
      });
      targetRibbons.attr("opacity",1);
    }
    
    // Set up the event handlers now
    rings.on("mouseout", restoreHighlights)
         .on("mouseover", function(event, d) {
              lowlightAll();
              highlightRings(d.index);
              highlightRibbons(d.index);
            });
    
    
    
    
    
    // Now let's see how you might make the arcs have nice gradients
    // We'll employ the clever defs ID technique from https://bl.ocks.org/JulienAssouline/2847e100ac7d4d3981b0f49111e185fe 
    
    // Define a simple function to generate gradient IDs from a ribbon object
    let getGradID = chord => `linkGrad-${chord.source.index}-${chord.target.index}`;

    // Now make the gradient definitions using a data join
    var grads = d3.select("#chord").append("defs")
      .selectAll("linearGradient")
      .data(chords)
      .join("linearGradient")
      .attr("id", getGradID)
      .attr("gradientUnits", "userSpaceOnUse")  // use the coordinate system of whatever is being filled
        // Note that we don't have access to transforms here -- we need to use x,y coordinates
        //  Yay, trigonometry!
      .attr("x1", d => radius * Math.cos((d.source.endAngle-d.source.startAngle) / 2 + d.source.startAngle - Math.PI/2) )
      .attr("y1", d => radius * Math.sin((d.source.endAngle-d.source.startAngle) / 2 + d.source.startAngle - Math.PI/2) )
      .attr("x2", d => radius * Math.cos((d.target.endAngle-d.target.startAngle) / 2 + d.target.startAngle - Math.PI/2) )
      .attr("y2", d => radius * Math.sin((d.target.endAngle-d.target.startAngle) / 2 + d.target.startAngle - Math.PI/2) )
    grads.append("stop")
      .attr("offset", "0%")
      .attr("stop-color", d => colorScale(nodes[ d.source.index ].Affiliation) )
    grads.append("stop")
      .attr("offset", "100%")
      .attr("stop-color", d => colorScale(nodes[ d.target.index ].Affiliation) )
    
    // Overwrite the old fill with a pointer to the gradient definition
    ribbons.attr("fill", d => "url(#" + getGradID(d) + ")" )
    
    
    
    
  }
  drawChord();

  
  

  

  </script>
  
  

  <!--- calls the highlight library to fill the <pre> tag with code --->
  <script>
  
  function sanitize(s) {
    return s.replace("<br>", "\\n")
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
          }
    document.getElementById("display1").innerHTML = sanitize( document.getElementById("notes1").innerText);
    hljs.highlightAll();
  </script>


  </div>
</body>
</html>
