<html><head>
<title>INFO 3300 - September 18</title>

  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  
  <link rel="stylesheet" type="text/css" href="../css/normalize.css">
  <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="../css/custom-style.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">
  <link rel="stylesheet" href="../css/hljs-base16.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  
  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <style>
  
    .legend span {
      margin-right: 10px;
    }
      
    .gridlines line {
      stroke: #bbb;
    }
    
    .gridlines .domain {
      stroke: none;
    }
    

  </style>

</head>
<body>
  <div class="container larger">
  <h3>Notes for September 18</h3>
  <p>
    Today we're looking at data joins. There are now two different ways to do a data join in d3.<br/>
     <a href="https://observablehq.com/@d3/selection-join">This page</a> demonstrates the "new" way to do joins.<br/>
     While <a href="https://bost.ocks.org/mike/join/">another page</a> demonstrates the "old" style of join.
  </p>
  <p>
     For this class the .join("elementName") pattern in a new style data join is often enough. You will start to use the .join(enter => {}, update => {}, exit => {} ) pattern when you have animated transitions or more involved steps in creating elements.
  </p>
  <p>
    If you're still confused about why we use translate to make scatterplots, Mike Bostock has a <a href="https://observablehq.com/@d3/margin-convention">handy page discussing chart margins</a>.
  </p>

  <h5>HTML for today:</h5>
  
    <p style="margin-top: 50px;">Data join demo:</p>
    <svg id="joinDemo" height="100" width="500" style="border: 1px solid black;" >
      
      
    </svg>
    
    <pre id="textSimulation">[ - - - - - - - - - ]</pre>

    <p style="margin-top: 50px;">Scatterplot:</p>
    
    <svg id="scatterplot" height="400" width="600" style="margin-top:50px" >
      <text id="label" x="590" y="5"  text-anchor="end" alignment-baseline="hanging"></text>
    </svg>
    


  <!-- This block will be automatically filled with syntax-highlighted code from the script below -->
  <h5>Code for today:</h5>
  <pre>
    <code id="display1" class="hljs javascript">
    </code>
  </pre>
  <pre>
    <code id="display2" class="hljs javascript">
    </code>
  </pre>
  
  <!--- Code for today's class --->
  <script id="notes1">


  // 0. Let's check out d3 joins
  const demo = d3.select("svg#joinDemo");
  
  // You can also use colors as a range in a d3 scale object!
  // Best if you make use of d3.rgb here
  // You also need to assign a function to blend the two colors with d3.interpolate()
  //  d3.interpolateHcl is almost always a safe bet
  let colorScale = d3.scaleLinear().domain([1,7])
                                   .range([d3.rgb("#a008f2"), d3.rgb("#f9d6ec")])
                                   .interpolate(d3.interpolateHcl);
  
  
  // This function is triggered every 800ms by the animation that I developed (see bottom of file)
  // Each tick of the animation changes the "circles" array slightly
  //  First, each circle gets 1 "age" older
  //  If a circle is over age 7, then it is removed
  //  A new circle is always added to the right of the newest one, looping around when it gets to the end
  // We want updateChart to draw a SVG circle for each element in the "circles" array onto our page
  // Done right, the circles being drawn and cleared will create the illusion of movement
  
  // So we have new circle elements to add, some circles to remove, and old ones to update
  // An old forEach loop would be hard to implement here, because we'd have to wipe the SVG clear each time
  // Instead, we use d3 data joins to simplify the process dramatically
  function updateChart(circles) {
    
    // Check out how the circles array changes over time
    //console.log(circles);
    //console.log(plaintextTicks(circles))
    
    // 1. Old way
    let elements = demo.selectAll("circle")
                       .data(circles);
                       // .data initiates a data join
                       // d3 will look at what the .selectAll returned (it's often empty at the start)
                       //  and compare it to the stuff you give .data().
                       // It tries to match up elements one-to-one with elements in the data
                       // Once it's done the join, you get access to functions based on the results
    
    // Exit => remove stuff
    //  .exit() returns a set of elements that are in the selectAll but no longer match anything in the .data()
    //  These should be removed
    elements.exit()
            .remove();
    
    // Enter => stuff you need to make
    //  .enter() returns a set of virtual elements that don't exist yet, but should exist because there are new things in .data()
    //  These should be added                   
    elements.enter()
            .append("circle")
            .attr("r", 20)
          // Update
          // Since .enter() only gave the new items, if we want to be able to style _everything_ from selectAll, we need to call .merge()
          //  .merge() will add any new objects from elements into the set you've made with .enter()
          // This means anything in the chain after the merge will affect all of the entities you've mapped to data elements
            .merge(elements)
            .attr("cx", d => d['x'] )
            .attr("cy", d => d['y'] )
            .attr("fill", d => colorScale(d.age));
    
    
    // 2. New way - shorthand version - what you'll use most often
    demo.selectAll("circle").data(circles)
        .join("circle") // If you give join an element name like "rect" or "circle", it uses defaults for
                        //  enter, update, and exit which add one of those elements or remove them as 
                        //  necessary. Its guesses are usually correct. Style stuff after the join
        .attr("r", 20)
        .attr("fill", d => colorScale(d.age) )
        .attr("cx", d => d['x'] )
        .attr("cy", d => d['y'] );
       
    // 3. New way - extended version
    //  You'll use this one when you have custom behavior for circles being added, changed, or removed
    //     (a good example of this is animating when circles enter and exit the canvas -- we'll do something like this in coming weeks )
    demo.selectAll("circle").data(circles)
        .join(  // .join() is a shortcut for handling the enter, update, and exit parts of a data join. Each is a parameter for join
          enter => { // the Enter parameter should be a function -- the function gets a parameter, enter, containing the set of stuff to create
            enter.append("circle")
                    .attr("r", 20)
                    .attr("fill", d => colorScale(d.age) )
                    .attr("cx", d => d['x'] )
                    .attr("cy", d => d['y'] );
          },
          update => update
                      .attr("cx", d => d['x'] )
                      .attr("cy", d => d['y'] )
                      .attr("fill", d => colorScale(d.age)), 
          // the Update parameter should be a function -- the function gets a parameter, update, containing the set of stuff that already exists and might need updating (but it does not include points you just created in enter)
          exit => { // the Exit parameter should be a function -- the function gets a parameter, exit, containing the set of stuff to remove
                    // Usually Exit is just for removing, but you can also use .transition() to animate removing things for special effects
            exit.remove() 
          }
        );
        
    // Avoid using .transition() within an extended join unless you know exactly what you are doing
    // It can easily interrupt the data join process
       
    
  }
  
  

  </script>
  
  
  
  
  <script id="notes2">
  
  
  // ------ We're going to edit some code to use a data join ------
  //   Scroll down to the forEach!
  
  const svg = d3.select("svg#scatterplot");
  const width = svg.attr("width");
  const height = svg.attr("height");
  const margin = {top: 10, right: 10, bottom: 50, left: 50};
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;

  let annotations = svg.append("g").attr("id","annotations");
  let chartArea = svg.append("g").attr("id","points")
                  .attr("transform","translate("+margin.left+","+margin.top+")");

  // Import some CSV data
  d3.csv("../datasets/blockbusters.csv", d3.autoType)
    .then( (data) => {
  
  // Check for data issues
  data.forEach( d => {
    d['worldwide_gross'] =  Number(d['worldwide_gross'].replace(/,/g,"").replace(/\$/g,""));
  });
  
  // Scales
  const yearExtent = d3.extent(data, d => d['year']);
  const yearScale = d3.scaleLinear().domain(yearExtent).range([0, chartWidth]);
  const grossExtent = d3.extent(data, d => d['worldwide_gross']);
  const grossScale = d3.scaleLog().domain(grossExtent).range([chartHeight, 0]);
  const imdbExtent = d3.extent(data, d => d['imdb_rating']);
  const imdbScale = d3.scaleLinear().domain(imdbExtent).range([3,8]);
  const genreScale = d3.scaleOrdinal( d3.schemeCategory10 )
  
  // Y axis
  let leftAxis = d3.axisLeft(grossScale)
                   .tickFormat(d3.format("$.0s"))
  let leftGridlines = d3.axisLeft(grossScale)
                        .tickSize(-chartWidth-10)
                        .tickFormat("")
  annotations.append("g")
    .attr("class", "y axis")
    .attr("transform","translate("+(margin.left-10)+","+margin.top+")")
    .call(leftAxis)
  annotations.append("g")
    .attr("class", "y gridlines")
    .attr("transform","translate("+(margin.left-10)+","+margin.top+")")
    .call(leftGridlines);
  
  // X axis
  let bottomAxis = d3.axisBottom(yearScale)
                     .tickFormat(d3.format("~f"));
  let bottomGridlines = d3.axisBottom(yearScale)
                          .tickSize(-chartHeight-10)
                          .tickFormat("")
  annotations.append("g")
    .attr("class", "x axis")
    .attr("transform","translate("+margin.left+","+(chartHeight+margin.top+10)+")")
    .call(bottomAxis);
  annotations.append("g")
    .attr("class", "x gridlines")
    .attr("transform","translate("+margin.left+","+(chartHeight+margin.top+10)+")")
    .call(bottomGridlines);
  
  
  // 1. Eliminate the data.forEach( (d, i) => { } )
  
  //  Update it using a data join!
  //  We can replace the .forEach with a .data().join() call
  //  While in the .forEach we had our own function (d, i) => {}, in the join things work differently
  //  We make use of the fact that commands like .attr and .style can access the element's data value
  //   in order to dynamically apply styles based on data -- this is d3's main selling point
  //  Though we use "d" here by convention, we're just putting a function into the second parameter of
  //   .attr() instead of a fixed value. The function has one parameter, the data row for that element
  let circles = chartArea.selectAll("circle").data(data)
                         .join("circle")
                         .attr("cx", d => yearScale(d['year']))
                         .attr("cy", d => grossScale(d['worldwide_gross']+1))
                         .attr("r", d => imdbScale(d['imdb_rating']))
                         .style("fill", d => genreScale(d['Main_Genre']) )
                         .attr("opacity", 0.8);
    
  console.log( genreScale.domain() )
                       
  // 2. Add some mouseovers
  //    Mouseover triggers when mouse enters object's region
  //    Mouseout triggers when mouse leaves the object's region
  //  WARNING: Avoid placing new elements on top of an object when using mouseover
  //           This can cause the two objects to fight, creating oscillating patterns                      
  //    This could also be written as chartArea.selectAll("circle").on() but storing a var is more efficient 
  circles.on("mouseover", function() {
    
      // This is the first time we've seen *this*    (asterisks just for emphasis)
      // When you're working with interactive events, you sometimes get access to *this*, a reserved
      //  keywork in Javascript for cases like mouseovers
      // *this* only works if you use function() at the top --- NO ANONYMOUS FUNCTIONS IN EVENTS
      // In the case of a mouseover, *this* refers to the thing you're mousing over
      // It means different things in different contexts - always check document
    
      d3.select(this)
        .transition().duration(200)
        .attr("stroke-width",4) // for some reason, .attr works better for animating strokes
        .attr("stroke","black")
        .style("fill", d => lighten( genreScale(d['Main_Genre']) ));
  
      // How do we get the data of a specific SVG object? We had d before from the .forEach
      //  but now we don't have it because of the join -- we need to access the element's data values somehow
      
      // Use the .datum() command!  (the singular form of "data")
      // (You can also use this to bind a big dataset to one object to do nested data joins)
      let title = d3.select(this).datum()['title']
  
      d3.select("#label")
        .text(title);
  });
  
  // Same story for the mouseout, but we don't have the title complication
  circles.on("mouseout", function() {
     // Make sure you use plain *this* and don't try to wrap it with quotes like "this"
     // It's a special reserved word
     
     d3.select(this)
       .transition().duration(200)  // to fix the appearance bug from the lecture, add a transition here too
       .attr("stroke-width",1)      //   it will override the old transition, preventing any values from getting
       .attr("stroke","none")       //   "stuck" and not reset properly
       .style("fill", d => genreScale(d['Main_Genre']) );

     d3.select("#label")
       .text("");
   });
  
   // This approach would NOT work if you needed to frequently join the circles (e.g. with a slider)
   // It risks adding multiple copies of mouseover events - you need to use ENTER separately in an extended join
    
  
  });
  
  </script>
  
  <script>
  
  // ----- Helper functions for today's lesson -----
  // Configure the simulation here
  // numCircles is also the age at which circles are removed
  const numCircles = 7;
  // how many empty spots you want to have in your visuals
  const emptySpots = 4;
  // the size of the viewport -- we can make it smaller than numCircles+emptySpots to make it look like it takes time to wrap around
  //  setting it to numCircles+emptySpots makes things immediately wrap around the SVG
  const viewport = 9;  // for wraparound use numCircles + emptySpots
  // space between circles
  const xSpacing = 50;
  const yPos = 50;
  // don't modify
  const maxLen = (numCircles + emptySpots) * xSpacing;
  
  // Simulation lives here
  var circles = [];
  
  // Steps the simulation one step forward, adding and removing elements as necessary
  var tick = function() {
      
    for (let i=0; i<circles.length; i++) {
      // Update circle age
      circles[i]['age'] = circles[i]['age'] + 1;
    }
    // If we have numCircles, remove the oldest one
    if (circles.length >= numCircles) {
      circles.shift();
    }
    // Always add a circle positioned after the most recent one
    let element;
    if (circles.length === 0) {
      element = { x: xSpacing, y: yPos, age: 1 };
    }
    else {
      let recent = circles[circles.length-1];
      element = { x: xSpacing + (recent.x % maxLen), y: yPos, age: 1 };
    }
    circles.push(element);
    
    // Update for viewport
    let view = [];
    for (let i=0; i<circles.length; i++) {
      if ( Math.floor(circles[i]['x'] / xSpacing) <= viewport ) {
        view.push(circles[i]);
      }
     }
    
    updateChart(view); // This goes to the data join function
    
    // This is a helper to print out the text version for reference
    d3.select("#textSimulation").text( plaintextTicks(circles) );
    
  }
  
  // This function makes a user-friendly text version of the simulation
  //  e.g. [ - 7 6 5 4 3 2 1 - - - ]
  // When a number is provided, that's the "age" of the circle
  function plaintextTicks(data) {
      let dir = [];
      for (let i=0; i<viewport; i++) {
          dir.push('-');
      }
      data.forEach( d => {
        if ( Math.floor(d.x / xSpacing) <= viewport ) {
          let pos = (d.x / xSpacing) - 1;
          dir[pos] = d.age;
        }
      })
      return '[ ' + dir.join(' ') + ' ]';
  }
  
  // setInterval causes a function (tick in this case) to be run every X milliseconds. It will do this forever unless you stop it
  setInterval( tick, 800 );
  
  
  

  // HELPER FUNCTION
  //  lighten a color a little bit using d3 color functions
  function lighten(color) {
      
      let hclColor = d3.hcl(color);
      let luma = Math.min(130, hclColor.l + 30);
      return d3.rgb( d3.hcl( hclColor.h, hclColor.c, luma ) );
    
  }

  
  </script>

  <!--- calls the highlight library to fill the <pre> tag with code --->
  <script>
  
  function sanitize(s) {
    return s.replace("<br>", "\\n")
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
          }
    document.getElementById("display1").innerHTML = sanitize( document.getElementById("notes1").innerText);
    document.getElementById("display2").innerHTML = sanitize( document.getElementById("notes2").innerText);
    hljs.highlightAll();
  </script>


  </div>
</body>
</html>
